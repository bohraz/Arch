[{"title":"About","type":0,"sectionRef":"#","url":"/Arch/docs/intro","content":"","keywords":""},{"title":"What is Arch?​","type":1,"pageTitle":"About","url":"/Arch/docs/intro#what-is-arch","content":"Arch is a sophisticated open-source hierarchical state machine library for Roblox, inspired by the SCXML specification. A state machine is a conceptual model that organizes the behavior of a system into distinct states, transitions, and actions. It's like a roadmap for your program, guiding it through different scenarios based on events or conditions. Arch adopts this idea and tailors it to Roblox projects, providing an organized and efficient way to manage the various states various game systems can be in. "},{"title":"Why Use Arch?​","type":1,"pageTitle":"About","url":"/Arch/docs/intro#why-use-arch","content":"Arch simplifies the complexities of state management, offering a versatile toolkit that benefits a variety of scenarios. Whether you're crafting combat systems, dynamic interfaces, or intricate artificial intelligence, Arch empowers developers by: Enhancing Logic Control: Navigate through diverse project states with precision, ensuring a seamless and immersive user experience. Improving Code Clarity: Streamline your codebase with efficient state transitions, contributing to better organization and maintainability. Optimizing Conflict Resolution: Benefit from Arch's conflict resolution mechanisms, providing a robust solution for handling complex scenarios.  Explore the documentation to understand how Arch can elevate your Roblox development by offering a valuable asset for creating responsive and engaging gameplay experiences. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Arch/docs/Getting Started","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/Getting Started#installation","content":""},{"title":"With Wally​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/Getting Started#with-wally","content":"Simply drop this snippet into wally. wally.toml [dependencies] Arch = &quot;bohraz/arch@0.2.0&quot;  "},{"title":"Quick Start​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/Getting Started#quick-start","content":"The quick start guide will help you get started with Arch. You will learn how to create a single-layer state machine and send events to it. "},{"title":"Creating a machine​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/Getting Started#creating-a-machine","content":"The simplest way to create a state machine is by passing a table into Arch.createMachine. The alternative is to pass a file hierarchy, which is described in later sections. In the following code we create a machine named toggleMachine with Active and Inactive states and a toggle event that transitions between them. local Arch = require(path.to.Arch) local toggleMachine = Arch.createMachine({ id = &quot;toggleMachine&quot;, initial = &quot;Inactive&quot;, states = { Active = { OnEntry = function(context, param1, param2) print(&quot;Toggle on!&quot;, param1, param2) end, OnExit = function(context) print(&quot;Toggle off!&quot;) end, events = { toggle = &quot;Inactive&quot; } }, Inactive = { OnInit = function(context) print(&quot;Initializing inactive state!&quot;) end, events = { toggle = &quot;Active&quot; } } } })  "},{"title":"Starting the machine and sending events​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/Getting Started#starting-the-machine-and-sending-events","content":"Now, all we have to do is start the machine and send events. toggleMachine:Start() --&gt; Initializing inactive state! toggleMachine:Send(&quot;toggle&quot;, 1, 2) --&gt; Toggle on! 1 2  "},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/Arch/docs/Core Concepts","content":"","keywords":""},{"title":"Machines​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#machines","content":""},{"title":"Defining Machines​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#defining-machines","content":"As mentioned earlier, there are two ways to define a machine during creation: with a dictionary or with a file hierarchy. Dictionary​ Dictionary.lua local myMachineDefinition = { id = &quot;myMachine&quot;, initial = &quot;StateA&quot;, states = { StateA = { initial = &quot;ChildStateA&quot;, states = { ChildStateA = {} } } } } local myMachine = Arch.createMachine(myMachineDefinition)  File Hierarchy​ Using a file hierarchy instead of a dictionary is useful for machines that have many layers of state nesting. To create a machine with a file hierarchy, you simply create a ModuleScript for the machine and each state and set the hierarchy accordingly. You can exclude the states property of each state because createMachine automatically builds it based on the file hierarchy. Finally, pass the machine ModuleScript Instance as the definition for createMachine. Here's an example: myMachine.lua local myMachine = {} myMachine.id = &quot;myMachine&quot; myMachine.initial = &quot;StateA&quot; return myMachine  StateA.lua --child of myMachine local state = {} state.id = &quot;StateA&quot; state.initial = &quot;ChildStateA&quot; return state  ChildStateA.lua --child of StateA local state = {} state.id = &quot;ChildStateA&quot; return state  initializeMyMachine.lua local myMachineFile = path.to.myMachine -- do not require, you must pass the actual ModuleScript Instance local myMachine = Arch.createMachine(myMachineFile)  "},{"title":"Options​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#options","content":"The options dictionary, which is the optional second parameter of createMachine, consists of several properties that change the behavior of the state machine or act as references for it. local options = { context = {}, -- the initial context of the machine passed to each state actions = {}, -- dictionary of actions that can be referenced by state and transition callbacks guards = {}, -- dictionary of guards that can be referenced by transitions maxLogs = 30, -- max logs in the log history, when the max is reached it deletes the oldest log logTime = true, -- wip determines whether or not to include a time property to each log debugMode = true, -- when set to true, the machine will print basic changes in the machine such as entering and exiting of states } local myMachine = Arch.createMachine(myMachineFile, options)  "},{"title":"States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#states","content":"States are the building blocks of all state machines. "},{"title":"Atomic States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#atomic-states","content":"An atomic state is a state without any child states. "},{"title":"Compound States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#compound-states","content":"One of the most powerful concepts in Arch is that states can have children states nested in them. These are called compound states, and their child states can have children states of their own proceeding to any depth. Ultimately we will reach a state that has no children, which is an atomic state. When a compound state is active, one and only one of its children is active. Every compound state must have an initial property which specifies the child state to be automatically entered after the compound state is entered. local myMachineDefinition = { id = &quot;myMachine&quot;, initial = &quot;StateA&quot;, states = { StateA = { initial = &quot;ChildStateA&quot;, states = { -- simply include a states table to make a compound state ChildStateA = {} } } } }  "},{"title":"History States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#history-states","content":"History states are compound states that include the history property, which can be set to shallow or deep. Before the state machine exits a compound state, it records the state's active descendants. If the history type is deep, the state machine remembers all of the active descendants, down to the atomic descendant(s). If the history type is shallow, the state machine remembers only which immediate child was active. When a transition takes a history state as its target, it enters the remembered states instead of those designated by initial properties. local myMachineDefinition = { id = &quot;myMachine&quot;, initial = &quot;myHistoryState&quot;, states = { myHistoryState = { initial = &quot;ChildA&quot;, -- initial must still be included for the first time the history state is entered history = &quot;shallow&quot;, -- or &quot;deep&quot; states = { ChildA = {}, ChildB = {} } } } }  "},{"title":"Parallel States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#parallel-states","content":"A parallel state, denoted by setting the parallel property of a compound state to true, is a state whose children are active at the same time. Whereas when a state machine enters a compound state it enters only one of its children, when a state machine enters a parallel state it enters all of its children. Transitions within the individual child elements operate normally. However whenever a transition is taken with a target outside the parallel state, the parallel state and all of its child states are exited and the corresponding OnExit handlers are executed. local myMachineDefinition = { id = &quot;myMachine&quot;, parallel = true, -- the initial property should be excluded if parallel is true states = { StateA = {}, -- both StateA and StateB will be active at the same time StateB = {}, } }  Note that the semantics of the parallel state does not call for multiple threads or truly concurrent processing. The children of parallel states execute in parallel in the sense that they are all simultaneously active and each one independently selects transitions for any event that is received. However, the parallel children process the event in a defined, serial order, so no conflicts or race conditions can occur. "},{"title":"Transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#transitions","content":"A transition is a change from one state to another, triggered by an event. It is important to consider that the existence of compound states implies that a transition may not just change from one state to another, but from one hierarchy of states to another. Transitions are &quot;deterministic&quot;, meaning each combination of state and event always points to the same next state. When a state machine receives an event, only the active states are checked to see if any of them have a transition for the event. The state that is being transitioned from is called the source, and the state that is being transitioned to is called the target. "},{"title":"Creating transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#creating-transitions","content":"Transitions are created by adding an events property to a state. The following examples, which have the same effect, show the three unique ways to create a transition. local state = {} state.id = &quot;StateA&quot; state.events = { Event1 = &quot;StateB&quot;, -- shorthand Event2 = { target = &quot;StateB&quot; }, -- allows for greater customizability of the transition Event3 = { { target = &quot;StateB&quot; } }, -- allows for multiple transitions in a single event, we will cover this next } return state  "},{"title":"Guards & Actions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#guards--actions","content":"Transitions can include a list of guards, which are functions that must return true in order to accept a transition. If an event has multiple transitions, the state machine checks each transition in order until all of a transition's guards return true, that becomes the selected transition. Guards can be literal functions or string references to the guards property of options. In the following example of an Idle state for a combat system, if the player activates their tool the state machine will check first if the player isJumping, a reference to the guards in options. If so, then a jump attack will play. If not, the state machine will check if the player isCrouching and if so perform a trip attack. state.id = &quot;Idle&quot; state.events = { ToolActivated = { { target = &quot;Jump Attack&quot;, guards = {&quot;isJumping&quot;} }, { target = &quot;Trip Attack&quot;, guards = {&quot;isCrouching&quot;} } } }  Transitions can also include a list of actions, which are functions that are to be called between exiting the source states and entering the target states. These actions can be literal functions or string references to the functions in the actions property of options. The actions specified in the actions table of a transition are executed in order. In the following example, guards and actions are used for a directional walking system. state.events = { updateWalkDirection = { guards = { &quot;isDifferentDirection&quot; }, actions = { &quot;exitAnimation&quot;, &quot;enterWalking&quot; } } }  "},{"title":"Delayed (after) transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/Core Concepts#delayed-after-transitions","content":"Delayed transitions are transitions that happen automatically after a specific interval of time. They are denoted in the &quot;after&quot; property of the events table like so: state.events = { after = { target = &quot;StateB&quot;, delay = 3 } -- automatically transitions to StateB after 3 seconds if no other transitions are called }  "}]