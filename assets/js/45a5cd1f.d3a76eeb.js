"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[365],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),d=c(a),u=i,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||r;return a?n.createElement(m,s(s({ref:t},h),{},{components:a})):n.createElement(m,s({ref:t},h))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},85059:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const r={sidebar_position:3},s="Core Concepts",o={unversionedId:"concepts",id:"concepts",title:"Core Concepts",description:"Machines",source:"@site/docs/concepts.md",sourceDirName:".",slug:"/concepts",permalink:"/Arch/docs/concepts",draft:!1,editUrl:"https://github.com/bohraz/Arch/edit/main/docs/concepts.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Getting Started",permalink:"/Arch/docs/start"},next:{title:"Lifecycle",permalink:"/Arch/docs/lifecycle"}},l={},c=[{value:"Machines",id:"machines",level:2},{value:"Defining Machines",id:"defining-machines",level:3},{value:"Dictionary",id:"dictionary",level:4},{value:"File Hierarchy",id:"file-hierarchy",level:4},{value:"Options",id:"options",level:3},{value:"States",id:"states",level:2},{value:"Atomic States",id:"atomic-states",level:3},{value:"Compound States",id:"compound-states",level:3},{value:"History States",id:"history-states",level:3},{value:"Parallel States",id:"parallel-states",level:3},{value:"Built-in garbage collection",id:"built-in-garbage-collection",level:3},{value:"Transitions",id:"transitions",level:2},{value:"Creating transitions",id:"creating-transitions",level:3},{value:"Guards &amp; Actions",id:"guards--actions",level:3},{value:"Delayed (after) transitions",id:"delayed-after-transitions",level:3}],h={toc:c},d="wrapper";function p(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"core-concepts"},"Core Concepts"),(0,i.kt)("h2",{id:"machines"},"Machines"),(0,i.kt)("h3",{id:"defining-machines"},"Defining Machines"),(0,i.kt)("p",null,"There are two ways to define a machine during creation: with a dictionary or with a file hierarchy."),(0,i.kt)("h4",{id:"dictionary"},"Dictionary"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Dictionary.lua"',title:'"Dictionary.lua"'},'local myMachineDefinition = {\n    id = "myMachine",\n    initial = "StateA",\n\n    states = {\n        StateA = {\n            initial = "ChildStateA",\n\n            states = {\n                ChildStateA = {}\n            }\n        }\n    }\n}\n\nlocal myMachine = Arch.createMachine(myMachineDefinition)\n')),(0,i.kt)("h4",{id:"file-hierarchy"},"File Hierarchy"),(0,i.kt)("p",null,"Using a file hierarchy instead of a dictionary is useful for machines that have many layers of state nesting.",(0,i.kt)("br",{parentName:"p"}),"\n","To create a machine with a file hierarchy, you simply create a ModuleScript for the machine and each state and set the hierarchy accordingly. You can exclude the ",(0,i.kt)("inlineCode",{parentName:"p"},"states")," property of each state because ",(0,i.kt)("inlineCode",{parentName:"p"},"createMachine")," automatically builds it based on the file hierarchy. Finally, pass the machine ModuleScript Instance as the definition for ",(0,i.kt)("inlineCode",{parentName:"p"},"createMachine"),". Here's an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="myMachine.lua"',title:'"myMachine.lua"'},'local myMachine = {}\n\nmyMachine.id = "myMachine"\nmyMachine.initial = "StateA"\n\nreturn myMachine\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="StateA.lua"',title:'"StateA.lua"'},'--child of myMachine\nlocal state = {}\n\nstate.id = "StateA"\nstate.initial = "ChildStateA"\n\nreturn state\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="ChildStateA.lua"',title:'"ChildStateA.lua"'},'--child of StateA\nlocal state = {}\n\nstate.id = "ChildStateA"\n\nreturn state\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="initializeMyMachine.lua"',title:'"initializeMyMachine.lua"'},"local myMachineFile = path.to.myMachine -- do not require, you must pass the actual ModuleScript Instance\n\nlocal myMachine = Arch.createMachine(myMachineFile)\n")),(0,i.kt)("h3",{id:"options"},"Options"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," dictionary, which is the optional second parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"createMachine"),", consists of several properties that change the behavior of the state machine or act as references for it.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"local options = {\n    context = {}, -- the initial context of the machine passed to each state\n    actions = {}, -- dictionary of actions that can be referenced by state and transition callbacks\n    guards = {}, -- dictionary of guards that can be referenced by transitions\n    maxLogs = 30, -- max logs in the log history, when the max is reached it deletes the oldest log\n    logTime = true, -- wip determines whether or not to include a time property to each log\n    debugMode = true, -- when set to true, the machine will print basic changes in the machine such as entering and exiting of states\n}\n\nlocal myMachine = Arch.createMachine(myMachineFile, options)\n")),(0,i.kt)("h2",{id:"states"},"States"),(0,i.kt)("p",null,"States are the building blocks of all state machines."),(0,i.kt)("h3",{id:"atomic-states"},"Atomic States"),(0,i.kt)("p",null,"An atomic state is a state without any child states."),(0,i.kt)("h3",{id:"compound-states"},"Compound States"),(0,i.kt)("p",null,"One of the most powerful concepts in Arch is that states can have children states nested in them. These are called compound states, and their child states can have children states of their own proceeding to any depth. Ultimately we will reach a state that has no children, which is an atomic state. When a compound state is active, one and only one of its children is active. Every compound state must have an ",(0,i.kt)("inlineCode",{parentName:"p"},"initial")," property which specifies the child state to be automatically entered after the compound state is entered."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local myMachineDefinition = {\n    id = "myMachine",\n    initial = "StateA",\n    states = {\n        StateA = {\n            initial = "ChildStateA",\n\n            states = { -- simply include a states table to make a compound state\n                ChildStateA = {}\n            }\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"history-states"},"History States"),(0,i.kt)("p",null,"History states are compound states that include the ",(0,i.kt)("inlineCode",{parentName:"p"},"history")," property, which can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"shallow")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"deep"),". Before the state machine exits a compound state, it records the state's active descendants. If the history type is ",(0,i.kt)("inlineCode",{parentName:"p"},"deep"),", the state machine remembers all of the active descendants, down to the atomic descendant(s). If the history type is ",(0,i.kt)("inlineCode",{parentName:"p"},"shallow"),", the state machine remembers only which immediate child was active. When a transition takes a history state as its target, it enters the remembered states instead of those designated by ",(0,i.kt)("inlineCode",{parentName:"p"},"initial")," properties."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local myMachineDefinition = {\n    id = "myMachine",\n    initial = "myHistoryState",\n    states = {\n        myHistoryState = {\n            initial = "ChildA", -- initial must still be included for the first time the history state is entered\n            history = "shallow", -- or "deep"\n            states = {\n                ChildA = {},\n                ChildB = {}\n            }\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"parallel-states"},"Parallel States"),(0,i.kt)("p",null,"A parallel state, denoted by setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"parallel")," property of a compound state to true, is a state whose children are active at the same time. Whereas when a state machine enters a compound state it enters only one of its children, when a state machine enters a parallel state it enters ",(0,i.kt)("em",{parentName:"p"},"all")," of its children. Transitions within the individual child elements operate normally. However whenever a transition is taken with a target outside the parallel state, the parallel state and all of its child states are exited and the corresponding OnExit handlers are executed.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local myMachineDefinition = {\n    id = "myMachine",\n    parallel = true, -- the initial property should be excluded if parallel is true\n    states = {\n        StateA = {}, -- both StateA and StateB will be active at the same time\n        StateB = {},\n    }\n}\n')),(0,i.kt)("p",null,"Note that the semantics of the parallel state does not call for multiple threads or truly concurrent processing. The children of parallel states execute in parallel in the sense that they are all simultaneously active and each one independently selects transitions for any event that is received. However, the parallel children process the event in a defined, serial order, so no conflicts or race conditions can occur."),(0,i.kt)("h3",{id:"built-in-garbage-collection"},"Built-in garbage collection"),(0,i.kt)("p",null,"By setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"janitor")," property of any state to true, a state-specific ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/howmanysmall/Janitor"},"Janitor"),' will be added to the state context OnEntry and cleaned up automatically OnExit. "Janitor makes dealing with garbage collection much less annoying and stressful because it manages them all in a nice interface."'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local myMachineDefinition = {\n    id = "myMachine",\n    initial = "StateA",\n    states = {\n        StateA = {\n            janitor = true\n            OnEntry = function(context)\n                local part = Instance.new("Part")\n                part.Parent = workspace\n                context.janitor:Add(part, "Destroy") -- automatically destroys this part when StateA is exited.\n            end,\n        }\n    }\n}\n')),(0,i.kt)("h2",{id:"transitions"},"Transitions"),(0,i.kt)("p",null,"A transition is a change from one state to another, triggered by an event. It is important to consider that the existence of compound states implies that a transition may not just change from one state to another, but from one hierarchy of states to another.",(0,i.kt)("br",{parentName:"p"}),"\n",'Transitions are "deterministic", meaning each combination of state and event always points to the same next state. When a state machine receives an event, only the active states are checked to see if any of them have a transition for the event. The state that is being transitioned from is called the source, and the state that is being transitioned to is called the target.'),(0,i.kt)("h3",{id:"creating-transitions"},"Creating transitions"),(0,i.kt)("p",null,"Transitions are created by adding an events property to a state. The following examples, which have the same effect, show the three unique ways to create a transition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local state = {}\n\nstate.id = "StateA"\nstate.events = {\n    Event1 = "StateB", -- shorthand \n    Event2 = { target = "StateB" }, -- allows for greater customizability of the transition\n    Event3 = { { target = "StateB" } }, -- allows for multiple transitions in a single event, we will cover this next\n}\n\nreturn state\n')),(0,i.kt)("h3",{id:"guards--actions"},"Guards & Actions"),(0,i.kt)("p",null,"Transitions can include a list of guards, which are functions that must return true in order to accept a transition. If an event has multiple transitions, the state machine checks each transition in order until all of a transition's guards return true, that becomes the selected transition. Guards can be literal functions or string references to the guards property of ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),". In the following example of an Idle state for a combat system, if the player activates their tool the state machine will check first if the player isJumping, a reference to the guards in ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),". If so, then a jump attack will play. If not, the state machine will check if the player isCrouching and if so perform a trip attack."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'state.id = "Idle"\nstate.events = {\n    ToolActivated = {\n        { target = "Jump Attack", guards = {"isJumping"} },\n        { target = "Trip Attack", guards = {"isCrouching"} }\n    }\n}\n')),(0,i.kt)("p",null,"Transitions can also include a list of actions, which are functions that are to be called between exiting the source states and entering the target states. These actions can be literal functions or string references to the functions in the actions property of ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),". The actions specified in the actions table of a transition are executed in order. In the following example, guards and actions are used for a directional walking system."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'state.events = {\n    updateWalkDirection = { guards = { "isDifferentDirection" }, actions = { "exitAnimation", "enterWalking" } }\n}\n')),(0,i.kt)("h3",{id:"delayed-after-transitions"},"Delayed (after) transitions"),(0,i.kt)("p",null,'Delayed transitions are transitions that happen automatically after a specific interval of time. They are denoted in the "after" property of the events table like so:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'state.events = {\n    after = { target = "StateB", delay = 3 } -- automatically transitions to StateB after 3 seconds if no other transitions are called\n}\n')))}p.isMDXComponent=!0}}]);