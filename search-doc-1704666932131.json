[{"title":"Lifecycle","type":0,"sectionRef":"#","url":"/Arch/docs/lifecycle","content":"Lifecycle Here I will describe the lifecycle of the machine's event loop and how it transitions.","keywords":""},{"title":"Machine","type":0,"sectionRef":"#","url":"/Arch/api/Machine","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Machine","url":"/Arch/api/Machine#functions","content":" "},{"title":"Start​","type":1,"pageTitle":"Machine","url":"/Arch/api/Machine#Start","content":"&lt;/&gt; Machine:Start() → () Starts the machine, initializing all states and entering the initial configuration.  "},{"title":"Stop​","type":1,"pageTitle":"Machine","url":"/Arch/api/Machine#Stop","content":"&lt;/&gt; Machine:Stop() → () Stops the machine, exiting all active states then destroying all states in the datamodel.  "},{"title":"Send​","type":1,"pageTitle":"Machine","url":"/Arch/api/Machine#Send","content":"&lt;/&gt; Machine:Send( eventName: string,-- name of the event to be sent to the machine ...: any-- all further parameters to be sent to all state and transition callbacks if the machine finds a transition for the event ) → () Sends events to the machine by adding to the event queue. "},{"title":"Arch","type":0,"sectionRef":"#","url":"/Arch/api/Arch","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#types","content":" "},{"title":"Context​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#Context","content":"&lt;/&gt; type Context = { janitor: any, event: string, Send: ( string, any ) → (), target: string?, any: any, }   "},{"title":"Action​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#Action","content":"&lt;/&gt; type Action = ( Context, any ) → ()   "},{"title":"Transition​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#Transition","content":"&lt;/&gt; type Transition = string | { target: string?, actions: {string | Action}?, guards: {string | Action}? } | {{ target: string?, actions: {string | Action}?, guards: {string | Action}? }}   "},{"title":"AtomicState​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#AtomicState","content":"&lt;/&gt; type AtomicState = { id: string, OnEntry: (string | Action)?, OnExit: (string | Action)?, events: {string: Transition}? }   "},{"title":"CompoundState​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#CompoundState","content":"&lt;/&gt; type CompoundState = AtomicState&amp;{ initial: string, states: States }   "},{"title":"ParallelState​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#ParallelState","content":"&lt;/&gt; type ParallelState = AtomicState&amp;{ parallel: true, states: States }   "},{"title":"HistoryState​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#HistoryState","content":"&lt;/&gt; type HistoryState = CompoundState&amp;{history: string}  "},{"title":"Functions​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#functions","content":" "},{"title":"createMachine​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#createMachine","content":"&lt;/&gt; Arch.createMachine( definition: Definition,-- the hierarchical structure that outlines the states, transitions, and behaviors of a state machine options: Options-- for tailoring the behavior of the state machine, setting initial context, and adding references for the definition ) → Machine "},{"title":"Types","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch##","content":""},{"title":"​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#Options","content":"type Options = { id: string, context: {any}?, actions: {string: ( Context, any ) → ()}?, guards: {string: ( Context, any ) → boolean}?, maxLogs: number?, logTime: boolean?, debugMode: boolean?, }  "},{"title":"​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#Definition","content":"type Definition = { id: string, initial: string?, parallel: boolean?, states: {string: (CompoundState | AtomicState | HistoryState | ParallelState)} } | ModuleScript   For creating a new hierarchical state machine. Constructs a state machine instance based on a provided definition and options list.  "},{"title":"getMachine​","type":1,"pageTitle":"Arch","url":"/Arch/api/Arch#getMachine","content":"&lt;/&gt; Arch.getMachine(id: string) → () Returns the machine with the matching id, if there is one. "},{"title":"About","type":0,"sectionRef":"#","url":"/Arch/docs/intro","content":"","keywords":""},{"title":"What is Arch?​","type":1,"pageTitle":"About","url":"/Arch/docs/intro#what-is-arch","content":"Arch is a sophisticated open-source hierarchical state machine library for Roblox, inspired by the SCXML specification. A state machine is a conceptual model that organizes the behavior of a system into distinct states, transitions, and actions. It's like a roadmap for your program, guiding it through different scenarios based on events or conditions. Arch adopts this idea and tailors it to Roblox projects, providing an organized and efficient way to manage the various states various game systems can be in. "},{"title":"Why Use Arch?​","type":1,"pageTitle":"About","url":"/Arch/docs/intro#why-use-arch","content":"Arch simplifies the complexities of state management, offering a versatile toolkit that benefits a variety of scenarios. Whether you're crafting combat systems, dynamic interfaces, or intricate artificial intelligence, Arch empowers developers by: Enhancing Logic Control: Navigate through diverse project states with precision, ensuring a seamless and immersive user experience. Improving Code Clarity: Streamline your codebase with efficient state transitions, contributing to better organization and maintainability. Optimizing Conflict Resolution: Benefit from Arch's conflict resolution mechanisms, providing a robust solution for handling complex scenarios.  Explore the documentation to understand how Arch can elevate your Roblox development by offering a valuable asset for creating responsive and engaging gameplay experiences. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Arch/docs/start","content":"","keywords":""},{"title":"Installation:​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/start#installation","content":"Include the Arch library in your Roblox project by installing it with wally or the Roblox Model and requiring it from the appropriate directory. wally.toml [dependencies] Arch = &quot;bohraz/arch@latest&quot;  local Arch = require(path.to.Arch)  "},{"title":"Define States and Transitions:​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/start#define-states-and-transitions","content":"Model your game's behavior by defining states and transitions within the Arch framework. Utilize the hierarchical structure to organize states efficiently. local myStateMachine = Arch.createMachine({ id = &quot;myStateMachine&quot;, initial = &quot;idle&quot;, states = { idle = { OnEntry = function() print(&quot;Entering idle state&quot;) end, OnExit = function() print(&quot;Exiting idle state&quot;) end, events = { startRunning = &quot;running&quot; } }, running = { initial = &quot;regularRunning&quot; OnEntry = function() print(&quot;Entering running state&quot;) end, OnExit = function() print(&quot;Exiting running state&quot;) end, events = { stopRunning = &quot;idle&quot; }, states = { regularRunning = { events = { jump = &quot;runningAndJumping&quot; } }, runningAndJumping = { OnEntry = function() print(&quot;Entering running and jumping state&quot;) end, } } }, }, })  "},{"title":"Start the State Machine and Send Events:​","type":1,"pageTitle":"Getting Started","url":"/Arch/docs/start#start-the-state-machine-and-send-events","content":"Initiate and start the state machine to begin managing states and handling transitions. myStateMachine:Start()  Use the Send method to trigger events and facilitate transitions between states. myStateMachine:Send(&quot;startRunning&quot;)  "},{"title":"Examples","type":0,"sectionRef":"#","url":"/Arch/docs/examples","content":"Examples Here we will describe some advanced examples and link to their github repos. If you make something cool you'd like to see on here just message me @bohraz on discord.","keywords":""},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/Arch/docs/concepts","content":"","keywords":""},{"title":"Machines​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#machines","content":""},{"title":"Defining Machines​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#defining-machines","content":"Every definition must have an id, an initial(or parallel = true) property, and a states table. Dictionary.lua local myMachineDefinition = { id = &quot;myMachine&quot;, initial = &quot;StateA&quot;, states = { StateA = { initial = &quot;ChildStateA&quot;, states = { ChildStateA = {} } } } } local myMachine = Arch.createMachine(myMachineDefinition)  "},{"title":"Options​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#options","content":"The options dictionary, which is the optional second parameter of createMachine, consists of several properties that change the behavior of the state machine or act as references for it. local options = { context = {}, -- the initial context of the machine passed to each state actions = {}, -- dictionary of actions that can be referenced by state and transition callbacks guards = {}, -- dictionary of guards that can be referenced by transitions maxLogs = 30, -- max logs in the log history, when the max is reached it deletes the oldest log logTime = true, -- determines whether or not to include a time property to each log debugMode = true, -- when set to true, the machine will print basic changes in the machine such as entering and exiting of states } local myMachine = Arch.createMachine(myMachineFile, options)  "},{"title":"States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#states","content":"States are the building blocks of all state machines. "},{"title":"Atomic States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#atomic-states","content":"An atomic state is a state without any child states. "},{"title":"Compound States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#compound-states","content":"One of the most powerful concepts in Arch is that states can have children states nested in them. These are called compound states, and their child states can have children states of their own proceeding to any depth. Ultimately we will reach a state that has no children, which is an atomic state. When a compound state is active, one and only one of its children is active. Every compound state must have an initial property which specifies the child state to be automatically entered after the compound state is entered. local myMachineDefinition = { id = &quot;myMachine&quot;, initial = &quot;StateA&quot;, states = { StateA = { initial = &quot;ChildStateA&quot;, states = { -- simply include a states table to make a compound state ChildStateA = {} } } } }  "},{"title":"History States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#history-states","content":"History states are compound states that include the history property, which can be set to shallow or deep. Before the state machine exits a compound state, it records the state's active descendants. If the history type is deep, the state machine remembers all of the active descendants, down to the atomic descendant(s). If the history type is shallow, the state machine remembers only which immediate child was active. When a transition takes a history state as its target, it enters the remembered states instead of those designated by initial properties. local myMachineDefinition = { id = &quot;myMachine&quot;, initial = &quot;myHistoryState&quot;, states = { myHistoryState = { initial = &quot;ChildA&quot;, -- initial must still be included for the first time the history state is entered history = &quot;shallow&quot;, -- or &quot;deep&quot; states = { ChildA = {}, ChildB = {} } } } }  "},{"title":"Parallel States​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#parallel-states","content":"A parallel state, denoted by setting the parallel property of a compound state to true, is a state whose children are active at the same time. Whereas when a state machine enters a compound state it enters only one of its children, when a state machine enters a parallel state it enters all of its children. Transitions within the individual child elements operate normally. However whenever a transition is taken with a target outside the parallel state, the parallel state and all of its child states are exited and the corresponding OnExit handlers are executed. local myMachineDefinition = { id = &quot;myMachine&quot;, parallel = true, -- the initial property should be excluded if parallel is true states = { StateA = {}, -- both StateA and StateB will be active at the same time StateB = {}, } }  Note that the semantics of the parallel state does not call for multiple threads or truly concurrent processing. The children of parallel states execute in parallel in the sense that they are all simultaneously active and each one independently selects transitions for any event that is received. However, the parallel children process the event in a defined, serial order, so no conflicts or race conditions can occur. "},{"title":"Transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#transitions","content":"A transition is a change from one state to another, triggered by an event. It is important to consider that the existence of compound states implies that a transition may not just change from one state to another, but from one hierarchy of states to another. Transitions are &quot;deterministic&quot;, meaning each combination of state and event always points to the same next state. When a state machine receives an event, only the active states are checked to see if any of them have a transition for the event. The state that is being transitioned from is called the source, and the state that is being transitioned to is called the target. "},{"title":"Creating transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#creating-transitions","content":"Transitions are created by adding an events property to a state. The following examples, which have the same effect, show the three unique ways to create a transition. StateA = { events = { Event1 = &quot;StateB&quot;, -- shorthand Event2 = { target = &quot;StateB&quot; }, -- allows for greater customizability of the transition Event3 = { { target = &quot;StateB&quot; } }, -- allows for multiple transitions in a single event, we will cover this next } }  "},{"title":"Guards & Actions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#guards--actions","content":"Transitions can include a list of guards, which are functions that must return true in order to accept a transition. If an event has multiple transitions, the state machine checks each transition in order until all of a transition's guards return true, that becomes the selected transition. Guards can be literal functions or string references to the guards property of options. In the following example of an Idle state for a combat system, if the player activates their tool the state machine will check first if the player isJumping, a reference to the guards in options. If so, then a jump attack will play. If not, the state machine will check if the player isCrouching and if so perform a trip attack. StateA = { events = { ToolActivated = { { target = &quot;Jump Attack&quot;, guards = {&quot;isJumping&quot;} }, { target = &quot;Trip Attack&quot;, guards = {&quot;isCrouching&quot;} } } } }  Transitions can also include a list of actions, which are functions that are to be called between exiting the source states and entering the target states. These actions can be literal functions or string references to the functions in the actions property of options. The actions specified in the actions table of a transition are executed in order. In the following example, guards and actions are used for a directional walking system. StateA = { events = { updateWalkDirection = { guards = { &quot;isDifferentDirection&quot; }, actions = { &quot;exitAnimation&quot;, &quot;enterWalking&quot; } } } }  "},{"title":"Delayed (after) transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#delayed-after-transitions","content":"Delayed transitions are transitions that happen automatically after a specific interval of time. They are denoted in the &quot;after&quot; property of the events table like so: StateA = { events = { after = { target = &quot;StateB&quot;, delay = 3 } -- automatically transitions to StateB after 3 seconds if no other transitions are called } }  "},{"title":"Targetless transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#targetless-transitions","content":"Targetless transitions are transitions that only run the transition's actions and do not change the state of the machine. StateA = { events = { myTargetlessTransition = { guards = { &quot;canDoMyTargetlessTransition&quot; }, actions = { &quot;updateSomething&quot; } } } }  "},{"title":"Self-transitions​","type":1,"pageTitle":"Core Concepts","url":"/Arch/docs/concepts#self-transitions","content":"Self transitions are transitions that exit and re-enter the current state, allowing a refresh behavior. StateA = { events = { mySelfTransition = { target = &quot;StateA&quot; } } }  "}]